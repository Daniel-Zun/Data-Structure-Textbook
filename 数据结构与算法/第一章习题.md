# 习题

# 上机题
`1.1` 设m、n均为自然数，m可表示为一些不超过n的自然数之和，试编写函数f(m,n)计算这种表示方式的数目。例如，f(5,3)=5，有5种表示方式：3+2、3+1+1、2+2+1、2+1+1+1、1+1+1+1+1。  
<br>

🧠**思路**：用dp把“整数划分”拆成：每次决定“用不用一个新数”，并通过一维数组逐步累加方案数。  
📃**代码**：
```
#include <iostream>
#include <vector>

using namespace std;

int main() 
{
    int m, n;
    cin >> m >> n;

    vector<long long> dp(m + 1, 0);             //dp[j]：当前条件下，表示整数 j 的方案数
    dp[0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= m; j++) {
            dp[j] += dp[j - i];
        }
    }

    cout << dp[m];
    return 0;
}
```

`1.2` 用C++的类声明定义“复数”的抽象数据类型。要求：  
（1）在复数内部用浮点数定义其实部和虚部。  
（2）实现3个构造函数：默认的构造函数没有参数；第二个构造函数将双精度浮点数赋给复数的实部，虚部置为0；第三个构造函数将两个双精度浮点数分别赋给复数的实部和虚部。  
（3）定义获取和修改复数的实部和虚部以及＋、一、*、/等运算的成员函数。  
（4）定义重载的流函数来输出一个复数。  
<br>

📃**代码**：
```
#include<iostream>

using namespace std;

class Plural
{
//（1）定义实部和虚部
private:
    double real;
    double imag;
public:
//（2）实现3个构造函数
    Plural()                            //默认构造函数
    {
        real = 0.0;
        imag = 0.0;
    }
    Plural(double real)                 //第二个构造函数，给实部赋值
    {
        this->real = real;
        imag = 0.0;
    }
    Plural(double real, double imag)    //第三个构造函数，给实部和虚部赋值
    {
        this->real = real;
        this->imag = imag;
    }
//（3）获取和修改复数的实部和虚部
    double getReal() const              //获取实部
    {
        return real;
    }
    double getImag() const              //获取虚部
    {
        return imag;
    }
    void setReal(double real)           //修改实部
    {
        this->real = real;
    }
    void setImag(double imag)           //修改虚部
    {
        this->imag = imag;
    }
//（3）定义运算成员函数
    Plural Plus(const Plural& a) const;
    Plural Minus(const Plural& a) const;
    Plural Time(const Plural& a) const;
    Plural Divide(const Plural& a) const;
//（4）定义重载的流函数以输出
    friend ostream& operator<<(ostream& out, const Plural& c);
};

Plural Plural::Plus(const Plural &a) const
{
    return Plural(a.real + real, a.imag + imag);
}

Plural Plural::Minus(const Plural &a) const
{
    return Plural(real - a.real, imag - a.imag);
}

Plural Plural::Time(const Plural &a) const
{
    return Plural(real * a.real - imag * a.imag, real * a.imag + imag * a.real);
}

Plural Plural::Divide(const Plural &a) const
{
    double denominator = a.real * a.real + a.imag * a.imag;
    return Plural((real * a.real + imag * a.imag) / denominator, (imag * a.real - real * a.imag) / denominator);
}

ostream& operator<<(ostream& out, const Plural& c)
{
    if (c.imag == 0)
    {
        out << c.real;
    }
    else if (c.imag > 0)
    {
        out << c.real << " + " << c.imag << "i";
    }
    else
    {
        out << c.real << " - " << -c.imag << "i";
    }
    return out;
}

int main()
{
    Plural a(2.0, 2.4);
    Plural b(5.6, -3.1);
//检验
    cout << a << endl;
    cout << b << endl;
    cout << a.Plus(b) << endl;
    cout << a.Minus(b) << endl;
    cout << a.Time(b) << endl;
    cout << a.Divide(b) << endl;

    return 0;
}
```

`1.3` 编写算法解决Josephus问题：设n个人围坐在一个圆桌周围，现在从第s个人开始报数，数到第m个人，让他出局；然后从出局的下一个人重新开始报数，数到第m个人，再让他出局……如此反复直到所有的人全部出局为止。对于任意给定的n、s和m，求出这n个人的出局序列。  
<br>

📃**代码：**
```

```
