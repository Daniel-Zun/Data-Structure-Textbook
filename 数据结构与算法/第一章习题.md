# 习题

# 上机题
`1.1` 设m、n均为自然数，m可表示为一些不超过n的自然数之和，试编写函数f(m,n)计算这种表示方式的数目。例如，f(5,3)=5，有5种表示方式：3+2、3+1+1、2+2+1、2+1+1+1、1+1+1+1+1。  
<br>

🧠**思路**：用dp把“整数划分”拆成：每次决定“用不用一个新数”，并通过一维数组逐步累加方案数。  
📃**代码**：
```
#include <iostream>
#include <vector>

using namespace std;

int main() 
{
    int m, n;
    cin >> m >> n;

    vector<long long> dp(m + 1, 0);             //dp[j]：当前条件下，表示整数 j 的方案数
    dp[0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= m; j++) {
            dp[j] += dp[j - i];
        }
    }

    cout << dp[m];
    return 0;
}
```

`1.2` 用C++的类声明定义“复数”的抽象数据类型。要求：  
（1）在复数内部用浮点数定义其实部和虚部。  
（2）实现3个构造函数：默认的构造函数没有参数；第二个构造函数将双精度浮点数赋给复数的实部，虚部置为0；第三个构造函数将两个双精度浮点数分别赋给复数的实部和虚部。  
（3）定义获取和修改复数的实部和虚部以及＋、一、*、/等运算的成员函数。  
（4）定义重载的流函数来输出一个复数。  
<br>

📃**代码**：
```
#include<iostream>

using namespace std;

class Plural
{
//（1）定义实部和虚部
private:
    double real;
    double imag;
public:
//（2）实现3个构造函数
    Plural()                            //默认构造函数
    {
        real = 0.0;
        imag = 0.0;
    }
    Plural(double real)                 //第二个构造函数，给实部赋值
    {
        this->real = real;
        imag = 0.0;
    }
    Plural(double real, double imag)    //第三个构造函数，给实部和虚部赋值
    {
        this->real = real;
        this->imag = imag;
    }
//（3）获取和修改复数的实部和虚部
    double getReal() const              //获取实部
    {
        return real;
    }
    double getImag() const              //获取虚部
    {
        return imag;
    }
    void setReal(double real)           //修改实部
    {
        this->real = real;
    }
    void setImag(double imag)           //修改虚部
    {
        this->imag = imag;
    }
//（3）定义运算成员函数
    Plural Plus(const Plural& a) const;
    Plural Minus(const Plural& a) const;
    Plural Time(const Plural& a) const;
    Plural Divide(const Plural& a) const;
//（4）定义重载的流函数以输出
    friend ostream& operator<<(ostream& out, const Plural& c);
};

Plural Plural::Plus(const Plural &a) const
{
    return Plural(a.real + real, a.imag + imag);
}

Plural Plural::Minus(const Plural &a) const
{
    return Plural(real - a.real, imag - a.imag);
}

Plural Plural::Time(const Plural &a) const
{
    return Plural(real * a.real - imag * a.imag, real * a.imag + imag * a.real);
}

Plural Plural::Divide(const Plural &a) const
{
    double denominator = a.real * a.real + a.imag * a.imag;
    return Plural((real * a.real + imag * a.imag) / denominator, (imag * a.real - real * a.imag) / denominator);
}

ostream& operator<<(ostream& out, const Plural& c)
{
    if (c.imag == 0)
    {
        out << c.real;
    }
    else if (c.imag > 0)
    {
        out << c.real << " + " << c.imag << "i";
    }
    else
    {
        out << c.real << " - " << -c.imag << "i";
    }
    return out;
}

int main()
{
    Plural a(2.0, 2.4);
    Plural b(5.6, -3.1);
//检验
    cout << a << endl;
    cout << b << endl;
    cout << a.Plus(b) << endl;
    cout << a.Minus(b) << endl;
    cout << a.Time(b) << endl;
    cout << a.Divide(b) << endl;

    return 0;
}
```

`1.3` 编写算法解决Josephus问题：设n个人围坐在一个圆桌周围，现在从第s个人开始报数，数到第m个人，让他出局；然后从出局的下一个人重新开始报数，数到第m个人，再让他出局……如此反复直到所有的人全部出局为止。对于任意给定的n、s和m，求出这n个人的出局序列。  
<br>

🧠**思路：**  
（1）环形列表枚举：直接枚举，用一个环形链表枚举删除的过程，重复 n - 1 次得到答案。    
（2）循环列表模拟：用 list 存 1..n，迭代器指向第 s 个，每轮走 m-1 步，输出并删除。    
（3）Fenwick树状数组。时间复杂度：O(n log <sup>n</sup>)  
📃**代码：**  
（1）环形列表枚举：时间复杂度：O(n<sup>2</sup>)
```
#include <iostream>
#include <vector>
using namespace std;

int main() 
{
    int n, s, m;
    cin >> n >> s >> m;
    vector<int> alive(n + 1, 1);
    int num = n;
    while (num) 
    {
        int step = m;
        while (step) 
        {
            // 如果当前位置已出局，先跳到下一个活人
            while (!alive[s]) 
            {
                s++;
                if (s > n) s = 1;
            }
            // 当前这个活人算一次报数
            step--; 
            // 还没数完，就移动到下一个位置继续
            if (step) 
            {
                s++;
                if (s > n) s = 1;
            }
        }
        // s 现在指向“数到 m 的那个人”
        alive[s] = 0;
        num--;
        cout << s << " ";
        // 下一轮从出局者的下一个人开始
        s++;
        if (s > n) s = 1;
    }
    return 0;
}
```
（2）循环列表模拟：时间复杂度：O(n * m)
```

```
